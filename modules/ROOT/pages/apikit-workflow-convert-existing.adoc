= Converting a Mule Project to an APIkit Project
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Whether you have chosen a backend-first design approach or already have a Mule application containing business logic that you want to expose as a REST service, it is possible to convert your existing Mule Project into an APIkit project.

Let's assume that you have chosen a backend-first implementation approach, and you have already created the following Mule application that retrieves users from a database:

[source,xml,linenums]
----
<mule>
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
	<flow name="GET-Users-FLOW">
		<http:listener config-ref="HTTP_Listener_config" path="/users"/>
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<http:listener config-ref="HTTP_Listener_config" path="/userById" />
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

== Manual Approach

This workflow guides you step-by-step to manually configure a functional router for your existing flows.

=== Step 1: Design Your API Specification

The initial step involves defining the API specification for your service.

To carry out this, you can refer to the options provided in the "Design Your API Specification" section of the document xref:apikit-4-implement-rest-api.adoc[Creating, Testing, and Implementing an API]. To illustrate this example, please create or copy the identical API specification and JSON example used in that workflow to the `/src/main/resources/api` folder.

=== Step 2: Create a Main Flow

Within the APIkit project, construct a main flow that serves as the entry point.

. Drag the following components from the Mule palette to the canvas:
+
* An HTTP Listener as a flow source
* An APIkit Router operation within the flow process
+
. In the properties editor for HTTP Listener, in *Connector Configuration*, make sure to select the existing `HTTP_Listener_Config`.
. Specify a listener path for the APIkit router. Enter `/api/*` in `Path` field.
. In the properties editor for APIkit Router, in *Router Configuration*, click the `Add` button to create a new configuration.
+
The *Global Element Properties* wizard appears.
. In *API Definition*, select the path `api/api.raml`.
. Accept configuration.
. Delete HTTP listener from `GET-Users-FLOW`.
. Delete HTTP listener from `GET-User-By-Id-FLOW`.

[source,xml,linenums]
----
<mule>
    <apikit:config outboundHeadersMapName="outboundHeadersMapName" httpStatusVarName="httpStatus" name="Router" api="api/api.raml" />
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
    <flow name="apiFlow">
		<http:listener config-ref="HTTP_Listener_config" path="/api/*"/>
		<apikit:router config-ref="Router"/>
	</flow>
	<flow name="GET-Users-FLOW">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

=== Step 3: Map API Resources-Actions to Flows

By default, each APIkit flow adheres to a naming convention for routing purposes, characterized by the following pattern:

`action:\resource[:content-type][:config-name]`

Where:

* `action`: The HTTP method
* `resource`: The HTTP resource
* `content-type`: Payload content-type (optional)
* `config-name`: APIkit router configuration name (optional)

To retain the original flow names and map each API resource-action to them, you can override this behavior by following these steps:

. Click the APIkit Router to open the *Properties Editor*. In *Router configuration*, click `Edit` button.
+
The *Global Element Properties* wizard appears.
+
. In *Mappings*, click `Add` button to create a new mapping configuration.
+
The *New Mapping* dialog appears.
. Use the drop-down to map the resources to actions.
+
* In the Resource drop-down, select `/users`.
+
* In the Action drop-down, select `Get`.
+
* In the Flow drop-down, select the flow that contains the get users action: `GET-Users-FLOW`.
+
* Click *OK*.
+
. In *Mappings*, click `Add` button again.
+
The *New Mapping* dialog appears.
. Use the drop-down to map the resources to actions.
+
* In the Resource drop-down, select `/users/userbyid`.
+
* In the Action drop-down, select `Get`.
+
* In the Flow drop-down, select the flow that contains the get users action: `GET-User-By-Id-FLOW`.
+
* Click *OK*.

[source,xml,linenums]
----
<mule>
    <apikit:config outboundHeadersMapName="outboundHeadersMapName" httpStatusVarName="httpStatus" name="Router" api="api/api.raml" >
		<apikit:flow-mappings >
			<apikit:flow-mapping resource="/users" action="get" flow-ref="GET-Users-FLOW" />
			<apikit:flow-mapping resource="/users/userbyid" action="get" flow-ref="GET-User-By-Id-FLOW" />
		</apikit:flow-mappings>
	</apikit:config>
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
    <flow name="apiFlow">
		<http:listener config-ref="HTTP_Listener_config" path="/api/*"/>
		<apikit:router config-ref="Router"/>
	</flow>
	<flow name="GET-Users-FLOW">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

== Scaffolding Approach

Following the same *Step 1: Design Your API Specification* as in the previous approach, once it is completed, an alternative workflow could involve scaffolding the API definition.

=== Step 2: Scaffold the API

Scaffold the API to auto-generate the main, console and resources flows:

. In *Package Explorer*, right-click on the `/src/main/resources/api/api.raml` file
. Select *Mule*
. Click on *Generate Flows from Local REST API*

A new XML file with the same name as the API is created containing the scaffolded flows.

NOTE: The main advantage of this approach is that you get the APIkit Router configuration, an error handler and the console flow out of the box, in addition to each flow that map the resources.

=== Step 3: Reference Flows

At this point, you have several options:

* Delete the flows that were scaffolded for each resource and map the original flows as mentioned in step 3 of the manual workflow.
* Remove any operations from the scaffolded flows and instead add a flow reference. This introduces an additional layer of indirection, which may not be desired.

[source,xml,linenums]
----
<mule>
...
    <flow name="get:\users\userbyid:api-config">
		<flow-ref name="GET-User-By-Id-FLOW"/>
    </flow>
    <flow name="get:\users:api-config">
		<flow-ref name="GET-Users-FLOW"/>
    </flow>
</mule>
----

* Transfer the content of the existing flows to the scaffolded flows that adhere to the routing naming convention. Indeed, if the application is extensive, performing the mentioned modifications can be a laborious task.

[source,xml,linenums]
----
<mule>
...
    <flow name="get:\users:api-config">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="get:\users\userbyid:api-config">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

Consider the size and complexity of the application when deciding on the best approach.

== Test the API

Now that your new project is set up, you are prepared to run it.

== See Also

* xref:apikit-4-xml-reference.adoc[]
* xref:apikit-error-handling-reference.adoc[]
