= Converting a Mule Project to an APIkit Project
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

If you choose a backend-first design approach for Mule projects and applications that contains business logic, you can convert them into an APIkit project and expose them as REST services. Use one of these approaches:
 
* xref:apikit-workflow-convert-existing.adoc#manual-approach[]
* xref:apikit-workflow-convert-existing.adoc#scaffolding-approach[]

The examples for these approaches are based on the following Mule application that retrieves users from a database:

[source,xml,linenums]
----
<mule>
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
	<flow name="GET-Users-FLOW">
		<http:listener config-ref="HTTP_Listener_config" path="/users"/>
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<http:listener config-ref="HTTP_Listener_config" path="/userById" />
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

== Manual Approach

Follow these steps to configure a functional router for your existing flows manually.

=== Step 1: Design Your API Specification

To define the API specification for your service, see xref:apikit-4-implement-rest-api.adoc#design-your-api-specification[Design Your API Specification at Building, Implementing, and Testing a REST API]. To illustrate this example, create or copy the API specification and JSON example used in that workflow to the `/src/main/resources/api` folder.

=== Step 2: Create a Main Flow

Within the APIkit project, construct a main flow that serves as the entry point.

. Drag the following components from the Mule palette to the canvas:
+
* An *HTTP Listener* as a flow source
* An *APIkit Router* operation within the flow process
+
. In the properties editor for the *HTTP Listener*, in *Connector Configuration*, select the existing `HTTP_Listener_Config`.
. Specify a listener path for the APIkit router. Enter `/api/*` in `Path` field.
. In the properties editor for the APIkit router, in *Router Configuration*, click `Add` to create a new configuration.
+
The *Global Element Properties* wizard appears.
. In *API Definition*, select the path `api/api.raml`.
. Accept the configuration.
. Delete the HTTP listener from `GET-Users-FLOW`.
. Delete the HTTP listener from `GET-User-By-Id-FLOW`.

[source,xml,linenums]
----
<mule>
    <apikit:config outboundHeadersMapName="outboundHeadersMapName" httpStatusVarName="httpStatus" name="Router" api="api/api.raml" />
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
    <flow name="apiFlow">
		<http:listener config-ref="HTTP_Listener_config" path="/api/*"/>
		<apikit:router config-ref="Router"/>
	</flow>
	<flow name="GET-Users-FLOW">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

=== Step 3: Map API Resources-Actions to Flows

By default, each APIkit flow adheres to a naming convention for routing purposes, characterized by the following pattern:

`action:\resource[:content-type][:config-name]`

[options="header"]
|===
| Name | Description
| `action` | HTTP method
| `resource` | HTTP resource
| `content-type` | Payload content-type (optional)
| `config-name` | APIkit router configuration name (optional)
|===

To retain the original flow names and map each API resource-action to them, override this behavior by following these steps:

. Select *APIkit Router* to open the *Properties Editor*. In *Router configuration*, click *Edit*.
+
The *Global Element Properties* wizard appears.
+
. In *Mappings*, click `Add` to create a new mapping configuration.
+
The *New Mapping* dialog appears.
. Use the drop-down to map the resources to actions.
+
* In the *Resource* drop-down, select `/users`.
+
* In the *Action* drop-down, select `Get`.
+
* In the *Flow* drop-down, select the flow that contains the get users action: `GET-Users-FLOW`.
+
* Click *OK*.
+
. In *Mappings*, click `Add`.
+
The *New Mapping* dialog appears.
. Use the drop-down to map the resources to actions.
+
* In the *Resource* drop-down, select `/users/userbyid`.
+
* In the *Action* drop-down, select `Get`.
+
* In the *Flow* drop-down, select the flow that contains the get users action: `GET-User-By-Id-FLOW`.
+
* Click *OK*.

[source,xml,linenums]
----
<mule>
    <apikit:config outboundHeadersMapName="outboundHeadersMapName" httpStatusVarName="httpStatus" name="Router" api="api/api.raml" >
		<apikit:flow-mappings >
			<apikit:flow-mapping resource="/users" action="get" flow-ref="GET-Users-FLOW" />
			<apikit:flow-mapping resource="/users/userbyid" action="get" flow-ref="GET-User-By-Id-FLOW" />
		</apikit:flow-mappings>
	</apikit:config>
    <http:listener-config name="HTTP_Listener_config">
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>
	<db:config name="Database_Config">
		<db:my-sql-connection host="localhost" port="3306" user="admin" password="admin" database="usersdb" />
	</db:config>
    <flow name="apiFlow">
		<http:listener config-ref="HTTP_Listener_config" path="/api/*"/>
		<apikit:router config-ref="Router"/>
	</flow>
	<flow name="GET-Users-FLOW">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="GET-User-By-Id-FLOW">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

== Scaffolding Approach

Follow the process at xref:apikit-workflow-convert-existing.adoc#step-1-design-your-api-specification[]. When completed, include an alternative workflow for scaffolding your API specification.

=== Step 2: Scaffold Your API Specification

Scaffold your API to auto-generate the main, console, and resources flows:

. In *Package Explorer*, right-click `/src/main/resources/api/api.raml`.
. Select *Mule*.
. Click *Generate Flows from Local REST API*.

A new XML file with the same name as the API is created containing the scaffolded flows.

NOTE: With this approach you get the APIkit router configuration, the error handler, and the console flow out of the box. You also get a flow that maps each resource.

=== Step 3: Reference Flows

At this point, you have some options:

* Delete the scaffolded flows for each resource and map the original flows as mentioned in xref:apikit-workflow-convert-existing.adoc#step-3:-map-api-resources-actions-to-flows
[].
* Remove any operations from the scaffolded flows and add a flow reference instead. By choosing this option you introduce an additional layer of indirection, which can be inconvenient in some scenarios.

[source,xml,linenums]
----
<mule>
...
    <flow name="get:\users\userbyid:api-config">
		<flow-ref name="GET-User-By-Id-FLOW"/>
    </flow>
    <flow name="get:\users:api-config">
		<flow-ref name="GET-Users-FLOW"/>
    </flow>
</mule>
----

* Transfer the content of the existing flows to the scaffolded flows that adhere to the routing naming convention. If the application is extensive, performing these modifications can be a laborious task.

[source,xml,linenums]
----
<mule>
...
    <flow name="get:\users:api-config">
		<db:select config-ref="Database_Config">
			<db:sql ><![CDATA[SELECT * FROM USERS]]></db:sql>
		</db:select>
	</flow>
	<flow name="get:\users\userbyid:api-config">
		<db:select config-ref="Database_Config" >
			<db:sql ><![CDATA[SELECT * FROM USERS WHERE :userIdParameter == userID]]></db:sql>
			<db:input-parameters ><![CDATA[#[{userIdParameter: attributes.queryParams.id}]]]></db:input-parameters>
		</db:select>
	</flow>
</mule>
----

Consider the size and complexity of the application when deciding on the best approach.

== Test Your API

Now that your new project is set up, you are ready to run it.

== See Also

* xref:apikit-4-xml-reference.adoc[]
* xref:apikit-error-handling-reference.adoc[]
